//! Execute code from a running WebAssembly instance on another thread.

#![allow(clippy::borrowed_box)] // Generated by derivative

use anyhow::Context;
use derivative::Derivative;
use wasm_bindgen::JsValue;
use wasmer::{AsStoreRef, MemoryType, Store};
use wasmer_wasix::{
    runtime::{
        task_manager::{TaskWasm, TaskWasmRun, TaskWasmRunProperties},
        SpawnMemoryType,
    },
    StoreSnapshot, WasiEnv, WasiFunctionEnv, WasiThreadError,
};

use super::scheduler_message::SchedulerMsg;

pub(crate) fn to_scheduler_message(
    task: TaskWasm<'_, '_>,
) -> Result<SchedulerMsg, WasiThreadError> {
    let TaskWasm {
        run,
        env,
        spawn_type,
        globals,
        ..
    } = task;

    let run_type = match spawn_type {
        wasmer_wasix::runtime::SpawnMemoryType::CreateMemory => WasmMemoryType::CreateMemory,
        wasmer_wasix::runtime::SpawnMemoryType::CreateMemoryOfType(ty) => {
            WasmMemoryType::CreateMemoryOfType(ty)
        }
        wasmer_wasix::runtime::SpawnMemoryType::CopyMemory(m, store) => {
            let memory_ty = m.ty(&store);
            WasmMemoryType::ShareMemory(memory_ty)
        }
        wasmer_wasix::runtime::SpawnMemoryType::ShareMemory(m, store) => {
            WasmMemoryType::ShareMemory(m.ty(&store))
        }
    };

    let store_snapshot = globals.cloned();
    let spawn_wasm = SpawnWasm {
        run,
        run_type,
        env,
        store_snapshot,
    };

    Ok(SchedulerMsg::SpawnWasm(spawn_wasm))
}

#[derive(Debug, Clone)]
pub(crate) enum WasmMemoryType {
    CreateMemory,
    CreateMemoryOfType(MemoryType),
    ShareMemory(MemoryType),
}

#[derive(Derivative)]
#[derivative(Debug)]
pub(crate) struct SpawnWasm {
    /// A blocking callback to run.
    #[derivative(Debug(format_with = "utils::hidden"))]
    run: Box<TaskWasmRun>,
    /// How the memory should be instantiated to execute the [`SpawnWasm::run`]
    /// callback.
    run_type: WasmMemoryType,
    /// WASI environment,
    pub(crate) env: WasiEnv,
    /// A snapshot of the instance store, used to fork from existing instances.
    store_snapshot: Option<StoreSnapshot>,
}

impl SpawnWasm {
    /// Execute the callback, blocking until it has completed.
    pub(crate) async fn execute(
        self,
        wasm_module: wasmer::Module,
        wasm_memory: wasmer::Memory,
        wbg_js_module: Option<JsValue>,
    ) -> Result<(), anyhow::Error> {
        let Self {
            run,
            run_type,
            env,
            store_snapshot,
        } = self;

        // Invoke the callback which will run the web assembly module
        let (ctx, store) = build_ctx_and_store(
            wasm_module,
            wasm_memory,
            env,
            store_snapshot,
            run_type,
            wbg_js_module.clone(),
        )
        .await
        .context("Unable to initialize the context and store")?;

        let properties = TaskWasmRunProperties {
            ctx,
            store,
            wbg_js_module,
        };
        run(properties).await?;

        Ok(())
    }
}

async fn build_ctx_and_store(
    module: wasmer::Module,
    memory: wasmer::Memory,
    env: WasiEnv,
    store_snapshot: Option<StoreSnapshot>,
    run_type: WasmMemoryType,
    wbg_js_module: Option<JsValue>,
) -> Option<(WasiFunctionEnv, Store)> {
    // Make a fake store which will hold the memory we just transferred
    let temp_store = env.runtime().new_store();
    let spawn_type = match run_type {
        WasmMemoryType::CreateMemory => SpawnMemoryType::CreateMemory,
        WasmMemoryType::CreateMemoryOfType(mem) => SpawnMemoryType::CreateMemoryOfType(mem),
        WasmMemoryType::ShareMemory(ty) => {
            assert_eq!(ty, memory.ty(&temp_store.as_store_ref()));
            SpawnMemoryType::ShareMemory(memory, temp_store.as_store_ref())
        }
    };

    let (ctx, store) = match WasiFunctionEnv::new_creating_store(
        module,
        env,
        store_snapshot.as_ref(),
        spawn_type,
        wbg_js_module,
    )
    .await
    {
        Ok(a) => a,
        Err(err) => {
            tracing::error!(
                error = &err as &dyn std::error::Error,
                "Failed to crate wasi context",
            );
            return None;
        }
    };
    Some((ctx, store))
}
